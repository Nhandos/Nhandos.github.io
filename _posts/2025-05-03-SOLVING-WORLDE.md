---
title: 3Blue1Brown's Wordle algorithm implementation in Rust
date: 2025-05-03 16:51:00 +0800
categories: [Computer Science]
tags: [algorithms]     
math: true
author: <nhan_dao>
---

> **TL;DR** I just formalised 3Blue1Brown's information theory approach to solving Wordle and implemented in Rust

## Wordle in one paragraph

Wordle is a single-player **Mastermind** variant played on five-letter English words. Each guess returns a five-symbol *pattern*:
* 2 / ðŸŸ© - correct letter, correct slot
* 1 / ðŸŸ¨ - letter exists elsewhere
* 0 / â¬œ - letter not in the word (or fully accounted for)

You win when the pattern is ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ© - and you have only six guesses. A solver's job is to choose guesses that zero-in on the secret word as fast as possible.

## Algorithm overview

### **Step 1: Build a 'prior' over the answer list**
Let 

$\mathcal{W} = \Set{\text{all five-letter words valid in a game of Wordle}\}$

be the dictionary, and treat the secret word as a random variable $W\in\mathcal{W}$. The **probability mass function** (pmf)

$P_W(w) = Pr\set{W=w}$

tells us how plausible each candidate is. I use a text corpus and weight the probabality of word based on their frequency.

$P_W(w) = \frac{\text{corpus frequency of w}}{\sum_{v\in\mathcal{W}}{frequency(v)}}$

### **Step 2: Turn a guess into a random pattern**

Take any guess $G\in\mathcal{W}$. Define the **scoring function** (e.g. the clue you get after a guess in a game of wordle) as

$f:\mathcal{W}\times\mathcal{W}\rightarrow\Set{0,1,2}^5$,

where $f(w, G) is the five-cell pattern you would see if the answer were $w$, each digit encodes a square:

| Code | Colour | Meaning                                  |
| ---- | ------ | ---------------------------------------- |
| 0    | â¬œ      | letter absent (or already accounted for) |
| 1    | ðŸŸ¨      | letter present elsewhere                 |
| 2    | ðŸŸ©      | correct letter *and* slot                |

Example

$f(\text{CRANE},\text{CARER}) = (2,0,1,2,1)$

Because $W$ is random, the pattern

$X = f(W,G)$

is also random. $X$ can take $3^5=\boldsymbol{243}$ values, encoded $0...242$

#### Distribution of patterns
Using the indicator function $\boldsymbol{1}[]$, the probability  of seeing a particular pattern $x$ given $G$ is 

$$
P_{X\mid G}(x)
= \sum_{w\in\mathcal{W}}\;
    \underbrace{\Pr\bigl\{W=w\bigr\}}_{=\,P_W(w)}
    \times
    \underbrace{\mathbf 1\!\bigl[f(w,G)=x\bigr]}_{1\text{ if pattern matches, else }0}
$$

A more conscise way of writing the formula above is

$$
P_{X\mid G}(x)
  \;=\;
  \sum_{\substack{w\in\mathcal{W}:\\ f(w,G)=x}}
        P_W(w).
$$

The equation above can be intepreted as: "*add up the prior probabilities of every word that would produce pattern* $\mathcal{x}$ *when you guess* $ G$".

### **Step 3: Score a guess with entropy**

Shannon entropy of $X$ given $G$ is 
$$
H(X\mid{G})=-\sum_{\mathcal{x}}{P_{X\mid G}(x)\log_2{P_{X\mid G}(x)}}
$$

Intuitively, **higher entropy** implies that the pattern generated by our guess carves up the remaining candidate set as evenly as possible --i.e our guess is expcted to rule out the largest chunk of unlikely words and leave the smallest plausible set for the hidden word $W$. The **3Blue1Brown** algorithm therefore chooses

$G_{optimal} = \arg\max_{G\in\mathcal{W}}{H(X\mid{G})}$

### **Step 4: Narrow down $\mathcal{W}$ and repeat from Step 2**

After playing the optimal guess $G$ and observing the actual pattern $x_{\text{true}} = f(w_{\text{true}},G)$, we eliminate any words that wouldn't have produced the pattern:

After playing guess $G_n$ and observing pattern $x_n=f(w_{\text{true}},G_n)$,

$\mathcal{W}_{n+1}\leftarrow\set{w\in{\mathcal{W}_n}:f(w,G_n)=x_n}$

We then:
1. Go back to **step 2** recompute $P_{X\mid G}(x)$ for every guess $G\in\mathcal{W}$, but sum only over the current answer set $\mathcal{W}_{n+1}$.
2. Pick the entropyâ€‘maximising guess $G_{n+1}$ 
3. Repeat these steps until the pattern is ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ© or six guesses are used.

## Rust implementation

For an implementation in Rust, see.

## Results

## Conclusion
